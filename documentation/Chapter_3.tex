%% Chapter-1.tex
%% Mac Radigan
%
%% Examples from SICP Chapter 3

    \section{Modularity, Objects, and State}
        \subsection{Assignment and Local State}
            \subsubsection{Local State Variables}
            \subsubsection{The Benefits of Introducing Assignment}
            \subsubsection{The Costs of Introducing Assignment}
        \subsection{The Environment Model of Evaluation}
            \subsubsection{The Rules for Evaluation}
            \subsubsection{Applying Simple Procedures}
            \subsubsection{Frames as the Repository of Local State}
            \subsubsection{Internal Definitions}
        \subsection{Modeling with Mutable Data}
            \subsubsection{Mutable List Structure}
            \subsubsection{Representing Queues}
            \subsubsection{Representing Tables}
            \subsubsection{A Simulator for Digital Circuits}
            \subsubsection{Propagation of Constraints}
        \subsection{Concurrency: Time Is of the Essence}
            \subsubsection{The Nature of Time in Concurrent Systems}
            \subsubsection{Mechanisms for Controlling Concurrency}
        \subsection{Streams}
            \subsubsection{Streams Are Delayed Lists}
Exercise 3.50.  Complete the following definition, which generalizes stream-map to allow procedures that take multiple arguments, analogous to map in section 2.2.3, footnote 12.
\begin{verbatim}
  (define (stream-map proc . argstreams)
    (if (<??> (car argstreams))
        the-empty-stream
        (<??>
         (apply proc (map <??> argstreams))
         (apply stream-map
                (cons proc (map <??> argstreams))))))
\end{verbatim}
              \schemelist{../chapter-3/sicp_ch3_e3-50.scm}
            \subsubsection{Infinite Streams}
            \subsubsection{Exploiting the Stream Paradigm}
            \subsubsection{Streams and Delayed Evaluation}
            \subsubsection{Modularity of Functional Programs and Modularity of Objects}

%% *EOF*
