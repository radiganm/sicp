%% Chapter-1.tex
%% Mac Radigan
%
%% Examples from SICP Chapter 3

    \section{Modularity, Objects, and State}
        \subsection{Assignment and Local State}
            \subsubsection{Local State Variables}

Exercise 3.1: An accumulator is a procedure that is called repeatedly with a single numeric argument and accumu- lates its arguments into a sum.  Each time it is called, it returns the currently accumulated sum. Write a procedure make-accumulator that generates accumulators, each main- taining an independent sum. The input to make-accumulator should specify the initial value of the sum; for example:
\begin{verbatim}
(define A (make-accumulator 5))

(A 10)
15

(A 10)
25
\end{verbatim}
              \schemelist{../chapter-3/sicp_ch3_e3-1.scm}
              \outlist{../chapter-3/sicp_ch3_e3-1.out}

Exercise 3.2: In so\ue039ware-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a pro- cedure make-monitored that takes as input a procedure, f , that itself takes one input. The result returned by make- monitored is a third procedure, say mf , that keeps track of the number of times it has been called by maintaining an internal counter. If the input to mf is the special symbol how-many-calls? , then mf returns the value of the counter.  If the input is the special symbol reset-count , then mf re- sets the counter to zero. For any other input, mf returns the result of calling f on that input and increments the counter.  For instance, we could make a monitored version of the sqrt procedure:

\begin{verbatim}
(define s (make-monitored sqrt))

(s 100)
10

(s 'how-many-calls?)
1
\end{verbatim}
              \schemelist{../chapter-3/sicp_ch3_e3-2.scm}
              \outlist{../chapter-3/sicp_ch3_e3-2.out}

            \subsubsection{The Benefits of Introducing Assignment}
            \subsubsection{The Costs of Introducing Assignment}
        \subsection{The Environment Model of Evaluation}
            \subsubsection{The Rules for Evaluation}
            \subsubsection{Applying Simple Procedures}
            \subsubsection{Frames as the Repository of Local State}
            \subsubsection{Internal Definitions}
        \subsection{Modeling with Mutable Data}
            \subsubsection{Mutable List Structure}
            \subsubsection{Representing Queues}
            \subsubsection{Representing Tables}
            \subsubsection{A Simulator for Digital Circuits}
            \subsubsection{Propagation of Constraints}
        \subsection{Concurrency: Time Is of the Essence}
            \subsubsection{The Nature of Time in Concurrent Systems}
            \subsubsection{Mechanisms for Controlling Concurrency}
        \subsection{Streams}
            \subsubsection{Streams Are Delayed Lists}
Exercise 3.50.  Complete the following definition, which generalizes stream-map to allow procedures that take multiple arguments, analogous to map in section 2.2.3, footnote 12.
\begin{verbatim}
  (define (stream-map proc . argstreams)
    (if (<??> (car argstreams))
        the-empty-stream
        (<??>
         (apply proc (map <??> argstreams))
         (apply stream-map
                (cons proc (map <??> argstreams))))))
\end{verbatim}
              \schemelist{../chapter-3/sicp_ch3_e3-50.scm}
            \subsubsection{Infinite Streams}
            \subsubsection{Exploiting the Stream Paradigm}
            \subsubsection{Streams and Delayed Evaluation}
            \subsubsection{Modularity of Functional Programs and Modularity of Objects}

%% *EOF*
